<!DOCTYPE html>
<html>
<head>
    <title>Nvgl8r Capture</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <style>
        body {
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            font-family: sans-serif;
            background: #000;
            color: #fff;
        }
        #video {
            position: absolute;
            width: 1px;
            height: 1px;
            opacity: 0;
            pointer-events: none;
        }
        #canvas {
            display: none;
        }
        #status {
            margin-top: 20px;
            font-size: 14px;
            color: #aaa;
        }
        .error {
            color: #ff4444;
        }
    </style>
</head>
<body>
    <div id="controls" style="width:100%;max-width:600px;">
        <label>Room name: <input id="room" type="text" placeholder="enter room to advertise"></label>
        <label>PIN: <input id="pin" type="text" placeholder="alphanumeric PIN"></label>
        <button id="startBtn">Start Capture & Advertise</button>
    </div>

    <video id="video" autoplay playsinline></video>
    <canvas id="canvas"></canvas>
    <div id="status">Idle</div>

    <script src="./p2p-crypto.js"></script>
    <script type="module">
        // Source and license for this here: https://github.com/gfodor/p2pcf
        import P2PCF from './p2pcf.js';
        // Configuration
        const MIN_INTERVAL = 5000;
        const MAX_INTERVAL = 10000;
        const CAPTURE_WIDTH = 640;
        const CAPTURE_HEIGHT = 480;
        const JPEG_QUALITY = 0.6; // keep payloads small

        // Elements
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const status = document.getElementById('status');
        const startBtn = document.getElementById('startBtn');
        const roomInput = document.getElementById('room');
        const pinInput = document.getElementById('pin');

        // Set up canvas
        canvas.width = CAPTURE_WIDTH;
        canvas.height = CAPTURE_HEIGHT;
        const ctx = canvas.getContext('2d');

        // Keep screen awake
        let wakeLock = null;
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    updateStatus('Screen wake lock active');
                }
            } catch (err) {
                updateStatus('Wake lock not supported');
            }
        }

    // P2P state
    let p2pcf = null; // p2pcf instance
    let derivedKey = null;
    let peerCount = 0;
    let cameraActive = false;

        // Initialize webcam
        async function initCamera() {
            if (cameraActive) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: CAPTURE_WIDTH }, height: { ideal: CAPTURE_HEIGHT } }
                });
                video.srcObject = stream;
                await requestWakeLock();
                cameraActive = true;
                updateStatus('Camera ready');
            } catch (err) {
                showError(`Camera error: ${err.message}`);
                status.classList.add('error');
                throw err;
            }
        }

        function closeCamera() {
            if (!cameraActive) return;
            const stream = video.srcObject;
            if (stream) {
                const tracks = stream.getTracks();
                tracks.forEach(track => track.stop());
            }
            video.srcObject = null;
            cameraActive = false;
            updateStatus('Camera closed');
        }

        function showError(text) {
            updateStatus(text, true);
        }

        function updateStatus(text, isError = false) {
            if (isError) {
                console.warn(text);
            } else {
                console.log(text);
            }
            status.textContent = text;
        }

        // Create a P2PCF host instance for the given room and wire events.
        function createPeer(room) {
            try {
                const uid = 'host-' + Math.floor(Math.random() * 100000);
                const p2 = new P2PCF(uid, room);

                p2.on('peerconnect', peer => {
                    peerCount = p2.peers.size || peerCount + 1;
                    updateStatus('Peer connected: ' + (peer.id ? peer.id.substring(0,5) : '') + ' (peers=' + (p2.peers.size || peerCount) + ')');
                });

                p2.on('peerclose', peer => {
                    peerCount = p2.peers.size || Math.max(0, peerCount - 1);
                    closeCamera();
                    updateStatus('Peer disconnected (peers=' + (p2.peers.size || peerCount) + ')');
                });

                p2.on('msg', (peer, data) => {
                    // incoming messages from peers (not expected for capture-only flow)
                    console.log('host received msg', peer && peer.id, data);
                });

                p2.start();
                return p2;
            } catch (e) {
                console.error('Failed to create P2PCF host', e);
                showError('Failed to initialize p2pcf host: ' + e.message);
                return null;
            }
        }

        async function captureAndSendLoop() {
            if (!peerCount) {
                updateStatus('Waiting for peer connection...');
                setTimeout(captureAndSendLoop, 3000);
                return;
            }
            if (!cameraActive) {
                await initCamera();
            }

            try {
                ctx.drawImage(video, 0, 0, CAPTURE_WIDTH, CAPTURE_HEIGHT);
                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', JPEG_QUALITY));
                const buffer = await P2PCrypto.blobToArrayBuffer(blob);
                const { ivBase64, ciphertext } = await P2PCrypto.encryptBuffer(buffer, derivedKey);

                // Build a small header
                const id = Date.now();
                const payload = JSON.stringify({ id, type: 'img', mime: 'image/jpeg', size: ciphertext.byteLength, iv: ivBase64, data: P2PCrypto.arrayBufferToBase64(ciphertext) });

                // Send header then ciphertext (assumes ordered reliable DataChannel)
                try {
                    p2pcf.broadcast(new TextEncoder().encode(payload));
                } catch (e) {
                    console.warn('send failed:', e);
                    updateStatus('Send failed: ' + e.message);
                }

                updateStatus(`Sent image ${id} (raw ${Math.round(buffer.byteLength/1024)} KB, encrypted ${Math.round(ciphertext.byteLength/1024)} KB)`);
            } catch (err) {
                console.error('capture/send error', err);
                showError('Error: ' + err.message);
                status.classList.add('error');
            }

            const nextInterval = Math.floor(MIN_INTERVAL + Math.random() * (MAX_INTERVAL - MIN_INTERVAL));
            setTimeout(captureAndSendLoop, nextInterval);
        }

        startBtn.addEventListener('click', async () => {
            const room = String(roomInput.value || '').trim();
            const pin = String(pinInput.value || '').trim();
            if (!room) {
                alert('Please enter a room name to advertise');
                return;
            }
            if (!pin) {
                alert('Please enter a PIN (alphanumeric)');
                return;
            }

            startBtn.disabled = true;
            try {
                derivedKey = await P2PCrypto.deriveKeyFromPIN(pin, room);

                updateStatus('Setting up P2P host...');
                p2pcf = createPeer(room);
                if (!p2pcf) {
                    updateStatus('Failed to create P2P session');
                    return;
                }

                // Start attempt to send images (will wait for peer if none connected)
                captureAndSendLoop(p2pcf);
            } catch (e) {
                console.error(e);
                updateStatus('Failed to start: ' + e.message);
                startBtn.disabled = false;
            }
        });

        // Keep wake lock on visibility
        document.addEventListener('visibilitychange', () => {
            if (document.visibilityState === 'visible') requestWakeLock();
        });
    </script>
</body>
</html>